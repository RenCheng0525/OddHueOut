<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Image Editor</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            display: flex;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            position: relative;
        }

        /* Drawer styles */
        .drawer {
            position: fixed;
            left: -240px;
            top: 0;
            bottom: 0;
            width: 280px;
            background: #ffffff;
            transition: transform 0.3s ease-in-out;
            z-index: 1000;
            display: flex;
        }

        .drawer.expanded {
            transform: translateX(240px);
        }

        /* Drawer handle */
        .drawer-handle {
            position: absolute;
            right: -40px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 80px;
            background: #1e293b;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: transform 0.3s ease-in-out;
        }

        /* Drawer content */
        .drawer-content {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow-y: auto;
            background: #ffffff;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
        }

        /* Button styles */
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 30px;
        }

        .btn-icon {
            font-size: 1.2em;
            margin-right: 8px;
            display: inline-flex;
            align-items: center;
        }

        .btn {
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            background: #f3f4f6;
            color: #4b5563;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #e0f2fe;
        }

        .btn-primary.active {
            background: #dbeafe;
            color: #1e40af;
        }

        .btn-secondary {
            background: #64748b;
            color: white;
        }

        .btn-danger {
            background: #dc2626;
            color: white;
        }

        .btn-success {
            background: #059669;
            color: white;
        }

        /* Canvas container */
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            touch-action: none;
        }

        #canvas,
        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            touch-action: none;
        }

        #imageInput {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .drawer {
                width: 260px;
                left: -260px;
            }

            .drawer.expanded {
                transform: translateX(260px);
            }
        }
    </style>
</head>

<body>
    <div class="drawer">
        <div class="drawer-handle">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M9 18l6-6-6-6" />
            </svg>
        </div>
        <div class="drawer-content">
            <div class="button-container">
                <button id="loadImage" class="btn btn-success">
                    <span class="btn-icon">üñºÔ∏è</span>
                    Load Image
                </button>
                <button id="drawMode" class="btn btn-primary active">
                    <span class="btn-icon">‚úèÔ∏è</span>
                    Draw Mode
                </button>
                <button id="shakeMode" class="btn btn-secondary">
                    <span class="btn-icon">üåä</span>
                    Shake Mode
                </button>
                <button id="clear" class="btn btn-danger">
                    <span class="btn-icon">üóëÔ∏è</span>
                    Clear All
                </button>
            </div>
            <input type="file" id="imageInput" accept="image/*">
        </div>
    </div>
    <div class="canvas-container">
        <canvas id="canvas"></canvas>
        <canvas id="overlay"></canvas>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</body>

<script>
    // === Core Variables Initialization ===
    const canvas = document.getElementById('canvas');
    const overlay = document.getElementById('overlay');
    const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true });
    const ctx = overlay.getContext('2d');

    // Drawing state variables
    let mode = 'draw';
    let isDrawing = false;
    let circles = [];
    let startPos = { x: 0, y: 0 };
    let currentPos = { x: 0, y: 0 };
    let isDragging = false;

    // Image-related variables
    let currentTexture = null;
    let backgroundImage = null;

    // === WebGL Shader Programs ===
    const vsSource = `
        attribute vec4 aVertexPosition;
        attribute vec2 aTextureCoord;
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        varying highp vec2 vTextureCoord;
    
        void main(void) {
            gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
            vTextureCoord = aTextureCoord;
        }
    `;

    const fsSource = `
        precision mediump float;
        varying highp vec2 vTextureCoord;
        uniform sampler2D uSampler;
    
        const int MAX_CIRCLES = 10;
        uniform vec2 uCenters[MAX_CIRCLES];  // Circle centers
        uniform float uRadii[MAX_CIRCLES];    // Circle radii
        uniform vec2 uForces[MAX_CIRCLES];    // Distortion forces
        uniform int uCircleCount;             // Number of circles
    
        void main(void) {
            vec2 pos = vTextureCoord;
            vec2 displacement = vec2(0.0);
    
            for (int i = 0; i < MAX_CIRCLES; i++) {
                if (i >= uCircleCount) break;
                
                vec2 pixelPos = pos * 2.0 - 1.0;
                vec2 toCenter = pixelPos - uCenters[i];
                float dist = length(toCenter);
                float influence = smoothstep(uRadii[i], 0.0, dist);
                displacement += uForces[i] * influence;
            }
    
            displacement *= 0.5;
            vec2 distortedCoord = clamp(pos + displacement, 0.0, 1.0);
            gl_FragColor = texture2D(uSampler, distortedCoord);
        }
    `;

    // === WebGL Program Initialization ===
    function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Unable to initialize shader program:', gl.getProgramInfoLog(shaderProgram));
            return null;
        }

        return shaderProgram;
    }

    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }

        return shader;
    }

    // Initialize WebGL program and attribute locations
    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
    const programInfo = {
        program: shaderProgram,
        attribLocations: {
            vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
            textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
        },
        uniformLocations: {
            projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
            modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
            uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
            uCenters: gl.getUniformLocation(shaderProgram, 'uCenters'),
            uRadii: gl.getUniformLocation(shaderProgram, 'uRadii'),
            uForces: gl.getUniformLocation(shaderProgram, 'uForces'),
            uCircleCount: gl.getUniformLocation(shaderProgram, 'uCircleCount'),
        },
    };

    // Initialize WebGL state
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    // === Mesh Generation and Buffer Management ===
    function createMesh(subdivisions = 30) {
        const positions = [];
        const textureCoords = [];
        const indices = [];

        // Generate vertices and texture coordinates
        for (let y = 0; y <= subdivisions; y++) {
            for (let x = 0; x <= subdivisions; x++) {
                // Vertex positions (-1 to 1 range)
                const xPos = (x / subdivisions) * 2 - 1;
                const yPos = (y / subdivisions) * 2 - 1;
                positions.push(xPos, yPos);

                // Texture coordinates (0 to 1 range)
                const u = x / subdivisions;
                const v = 1.0 - (y / subdivisions); // Flip V coordinate
                textureCoords.push(u, v);
            }
        }

        // Generate triangle indices
        for (let y = 0; y < subdivisions; y++) {
            for (let x = 0; x < subdivisions; x++) {
                const i = y * (subdivisions + 1) + x;
                indices.push(
                    i, i + 1, i + subdivisions + 1,
                    i + 1, i + subdivisions + 2, i + subdivisions + 1
                );
            }
        }

        return {
            positions: new Float32Array(positions),
            textureCoords: new Float32Array(textureCoords),
            indices: new Uint16Array(indices),
        };
    }

    // Buffer initialization
    const buffers = {
        position: gl.createBuffer(),
        textureCoord: gl.createBuffer(),
        indices: gl.createBuffer(),
    };

    function initBuffers(mesh) {
        // Vertex position buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.positions, gl.STATIC_DRAW);

        // Texture coordinate buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
        gl.bufferData(gl.ARRAY_BUFFER, mesh.textureCoords, gl.STATIC_DRAW);

        // Index buffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.indices, gl.STATIC_DRAW);
    }

    // === Texture Management ===
    function isPowerOf2(value) {
        return (value & (value - 1)) === 0;
    }

    function loadTexture(gl, image) {
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        // Upload image to GPU
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        // Set texture parameters
        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
            gl.generateMipmap(gl.TEXTURE_2D);
        } else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        }

        return texture;
    }

    // === Canvas Size and Coordinate Management ===
    function calculateOptimalCanvasSize(image) {
        const maxWidth = window.innerWidth * 0.9;
        const maxHeight = window.innerHeight * 0.8;

        let optimalWidth = image.width;
        let optimalHeight = image.height;

        if (optimalWidth > maxWidth || optimalHeight > maxHeight) {
            const ratio = Math.min(maxWidth / optimalWidth, maxHeight / optimalHeight);
            optimalWidth *= ratio;
            optimalHeight *= ratio;
        }

        return {
            width: Math.round(optimalWidth),
            height: Math.round(optimalHeight)
        };
    }

    function getMousePosition(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
        };
    }

    // Initialize base mesh
    let mesh = createMesh();
    initBuffers(mesh);

    // === Drawing and Rendering Functions ===
    function resizeCanvas() {
        if (!backgroundImage) return;

        const size = calculateOptimalCanvasSize(backgroundImage);
        canvas.width = size.width;
        canvas.height = size.height;
        overlay.width = size.width;
        overlay.height = size.height;

        gl.viewport(0, 0, size.width, size.height);

        if (currentTexture) {
            gl.deleteTexture(currentTexture);
        }
        drawBackground();
    }

    function drawBackground() {
        if (!backgroundImage) return;

        if (currentTexture) {
            gl.deleteTexture(currentTexture);
        }
        currentTexture = loadTexture(gl, backgroundImage);

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }

    function drawScene() {
        if (!currentTexture) return;

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(programInfo.program);

        // Set up matrices
        const projectionMatrix = mat4.create();
        const modelViewMatrix = mat4.create();

        gl.uniformMatrix4fv(
            programInfo.uniformLocations.projectionMatrix,
            false,
            projectionMatrix
        );
        gl.uniformMatrix4fv(
            programInfo.uniformLocations.modelViewMatrix,
            false,
            modelViewMatrix
        );

        // Bind texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, currentTexture);
        gl.uniform1i(programInfo.uniformLocations.uSampler, 0);

        // Set up circle data
        let centers = [];
        let radii = [];
        let forces = [];

        circles.forEach(circle => {
            centers.push((circle.x / canvas.width) * 2 - 1);
            centers.push((circle.y / canvas.height) * 2 - 1);
            radii.push((circle.radius / Math.min(canvas.width, canvas.height)) * 2);
            forces.push((circle.offsetX / canvas.width) * 2);
            forces.push((circle.offsetY / canvas.height) * 2);
        });

        // Pad arrays to match MAX_CIRCLES
        while (centers.length < 20) centers.push(0);
        while (radii.length < 10) radii.push(0);
        while (forces.length < 20) forces.push(0);

        // Upload data to WebGL
        gl.uniform2fv(programInfo.uniformLocations.uCenters, new Float32Array(centers));
        gl.uniform1fv(programInfo.uniformLocations.uRadii, new Float32Array(radii));
        gl.uniform2fv(programInfo.uniformLocations.uForces, new Float32Array(forces));
        gl.uniform1i(programInfo.uniformLocations.uCircleCount, circles.length);

        // Set up vertex attributes
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
        gl.vertexAttribPointer(
            programInfo.attribLocations.vertexPosition,
            2, gl.FLOAT, false, 0, 0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
        gl.vertexAttribPointer(
            programInfo.attribLocations.textureCoord,
            2, gl.FLOAT, false, 0, 0
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);

        // Draw
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
        gl.drawElements(gl.TRIANGLES, mesh.indices.length, gl.UNSIGNED_SHORT, 0);
    }

    function updateOverlay() {
        ctx.clearRect(0, 0, overlay.width, overlay.height);

        if (mode === 'draw') {
            // Draw existing circles
            circles.forEach(circle => {
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw preview circle while drawing
            if (isDrawing) {
                const radius = Math.sqrt(
                    Math.pow(currentPos.x - startPos.x, 2) +
                    Math.pow(currentPos.y - startPos.y, 2)
                );

                ctx.beginPath();
                ctx.arc(startPos.x, startPos.y, radius, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
    }

    // === Animation and Physics Functions ===
    function updatePhysics() {
        circles.forEach(circle => {
            if (!circle.isDragging) {
                // Apply spring effect
                circle.offsetX *= 0.9;
                circle.offsetY *= 0.9;
            }
        });
    }

    function animate() {
        if (mode === 'shake') {
            updatePhysics();
        }
        drawScene();
        updateOverlay();
        requestAnimationFrame(animate);
    }

    // Start animation loop
    animate();

    // === Drawer Control ===
    const drawer = document.querySelector('.drawer');
    const drawerHandle = document.querySelector('.drawer-handle');
    let isDrawerExpanded = false;

    function initializeDrawer() {
        // Handle click on drawer handle
        drawerHandle.addEventListener('click', toggleDrawer);

        // Touch/Mouse event handling for drawer
        let touchStartX = 0;
        let touchStartY = 0;
        let isDraggingDrawer = false;

        drawer.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            isDraggingDrawer = true;
        }, { passive: true });

        drawer.addEventListener('touchmove', (e) => {
            if (!isDraggingDrawer) return;

            const touchEndX = e.touches[0].clientX;
            const touchEndY = e.touches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = Math.abs(touchEndY - touchStartY);

            // Only handle horizontal swipes
            if (deltaY < Math.abs(deltaX)) {
                // Swipe right to open
                if (deltaX > 50 && !isDrawerExpanded) {
                    expandDrawer();
                }
                // Swipe left to close
                else if (deltaX < -50 && isDrawerExpanded) {
                    collapseDrawer();
                }
            }
        }, { passive: true });

        drawer.addEventListener('touchend', () => {
            isDraggingDrawer = false;
        }, { passive: true });
    }

    function toggleDrawer() {
        if (isDrawerExpanded) {
            collapseDrawer();
        } else {
            expandDrawer();
        }
    }

    function expandDrawer() {
        drawer.classList.add('expanded');
        isDrawerExpanded = true;
        drawerHandle.style.transform = 'translateY(-50%) rotate(180deg)';
    }

    function collapseDrawer() {
        drawer.classList.remove('expanded');
        isDrawerExpanded = false;
        drawerHandle.style.transform = 'translateY(-50%)';
    }

    // === Canvas Event Handlers ===
    const container = document.querySelector('.canvas-container');

    function handleCanvasStart(e) {
        if (!backgroundImage) return;

        const pos = getMousePosition(e);

        if (mode === 'draw') {
            isDrawing = true;
            startPos = pos;
            currentPos = pos;
        } else if (mode === 'shake') {
            isDragging = true;
            startPos = pos;
        }
    }

    function handleCanvasMove(e) {
        if (!backgroundImage) return;

        const pos = getMousePosition(e);
        currentPos = pos;

        if (mode === 'draw' && isDrawing) {
            updateOverlay();
        } else if (mode === 'shake' && isDragging) {
            const dx = pos.x - startPos.x;
            const dy = pos.y - startPos.y;

            circles.forEach(circle => {
                circle.offsetX = dx * 0.5;
                circle.offsetY = dy * 0.5;

                const maxOffset = circle.radius * 0.5;
                circle.offsetX = Math.max(-maxOffset, Math.min(maxOffset, circle.offsetX));
                circle.offsetY = Math.max(-maxOffset, Math.min(maxOffset, circle.offsetY));
            });

            startPos = pos;
        }
    }

    function handleCanvasEnd() {
        if (mode === 'draw' && isDrawing && backgroundImage) {
            const radius = Math.sqrt(
                Math.pow(currentPos.x - startPos.x, 2) +
                Math.pow(currentPos.y - startPos.y, 2)
            );

            if (radius > 5) {
                circles.push({
                    x: startPos.x,
                    y: startPos.y,
                    radius: radius,
                    offsetX: 0,
                    offsetY: 0
                });
            }
        }

        isDrawing = false;
        isDragging = false;
    }

    // === Event Listeners ===
    // Mouse events for canvas
    container.addEventListener('mousedown', handleCanvasStart);
    container.addEventListener('mousemove', handleCanvasMove);
    container.addEventListener('mouseup', handleCanvasEnd);
    container.addEventListener('mouseleave', handleCanvasEnd);

    // Touch events for canvas
    container.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleCanvasStart(e.touches[0]);
    }, { passive: false });

    container.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleCanvasMove(e.touches[0]);
    }, { passive: false });

    container.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleCanvasEnd();
    }, { passive: false });

    // Button click handlers
    document.getElementById('drawMode').addEventListener('click', () => {
        mode = 'draw';
        document.getElementById('drawMode').className = 'btn btn-primary active';
        document.getElementById('shakeMode').className = 'btn btn-secondary';

        circles.forEach(circle => {
            circle.offsetX = 0;
            circle.offsetY = 0;
        });
    });

    document.getElementById('shakeMode').addEventListener('click', () => {
        mode = 'shake';
        document.getElementById('shakeMode').className = 'btn btn-primary active';
        document.getElementById('drawMode').className = 'btn btn-secondary';
    });

    document.getElementById('clear').addEventListener('click', () => {
        circles = [];
        drawScene();
        updateOverlay();
    });

    document.getElementById('loadImage').addEventListener('click', () => {
        document.getElementById('imageInput').click();
    });

    document.getElementById('imageInput').addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
            try {
                circles = [];
                const reader = new FileReader();
                reader.onload = (event) => {
                    const image = new Image();
                    image.onload = () => {
                        backgroundImage = image;
                        resizeCanvas();
                    };
                    image.src = event.target.result;
                };
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('Failed to load image:', error);
            }
        }
    });

    // Initialize drawer and handle window resize
    initializeDrawer();
    window.addEventListener('resize', resizeCanvas);
</script>

</html>
